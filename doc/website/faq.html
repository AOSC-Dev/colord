<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>colord - Frequently Asked Questions</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<link rel="stylesheet" href="style.css" type="text/css" media="screen"/>
<link rel="shortcut icon" href="favicon.ico"/>
</head>
<body>

<p>Back to the <a href="index.html">main page</a></p>

<h1>Frequently asked questions</h1>

<h2>Table Of Contents</h2>
<ul>
<li><a href="#spelling">Can I type colord with leading upper case 'C'?</a></li>
<li><a href="#gcm">How does this work with gnome-color-manager?</a></li>
<li><a href="#XRandR13">Are XRandR 1.2 devices still supported?</a></li>
<li><a href="#imageloading">Does colord or GNOME Color Manager convert my image?</a></li>
<li><a href="#whydbnotxml">Why are the mappings stored in a database, not readable XML files?</a></li>
<li><a href="#nvidia-driver">Does calibration work with the NVIDIA binary driver?</a></li>
<li><a href="#cmm-cmf-cms">What is the difference between a CMM, CMF and a CMS?</a></li>
<!--
<li><a href="#xxx">xxx</a></li>
-->
<li><a href="#sensors">What is a native sensor?</a></li>
<li><a href="#application">How would an application like Simple Scan use colord?</a></li>
<li><a href="#qualifiers">What is a qualifier used for?</a></li>
<li><a href="#daemon">How do system daemons add devices and profiles?</a></li>
<li><a href="#cups">How would a system daemon like CUPS use colord?</a></li>
<li><a href="#translation">How do I translate gnome-color-manager?</a></li>
<li><a href="#corporate-sponsor">Is there an organization sponsoring development of colord?</a></li>
<li><a href="#oyranos">Why did you start a new project instead of fixing Oyranos?</a></li>
<li><a href="#why-root">Why does the daemon run as root?</a></li>
</ul>

<hr/>
<h3><a name="spelling">Can I type colord with leading upper case 'C'</a></h3>
<p>
No.
</p>

<hr/>
<h3><a name="gcm">How does this work with gnome-color-manager?</a></h3>
<p>
At start-up GCM has to create profiles, devices and otherwise act as the
helper agent for colord in that user session.
GNOME Color Manager basically has to do the following 6 things:
</p>
<ul>
<li>
 Call <code>CreateDevice</code> for each connected XRandR screen and
 watch for changes to the screen.
</li>
<li>
 Create an ICC profile file for each XRandR device using the EDID
 primary information and store it in the home directory.
</li>
<li>
 Call <code>CreateProfile</code> for each profile found in the home
 directory.</li>
<li>
 For each <code>::profile-added</code> event check if the
 <code>EDID_md5</code> metadata matches any XRandR devices.
 If it does, then it needs to call <code>Device.AddProfile()</code>
</li>
<li>
 For each <code>::device-added</code> event check if the device
 <code>modified</code> property is beyond a set threshold.
 If it is, show a notification that the user should calibrate the device.
</li>
<li>
 For each <code>::device-added</code> event from a XRandR device,
 get the default profile and push the gamma ramp to the X output.
</li>
</ul>


<hr/>
<h3><a name="XRandR13">Are XRandR 1.2 devices still supported?</a></h3>
<p>
No. XRandR 1.3 is required to do per-output gamma correction.
</p>

<hr/>
<h3><a name="imageloading">Does colord or GNOME Color Manager convert my image?</a></h3>
<p>
No. You need to use a pixel conversion library, for instance
<a href="http://www.littlecms.com/">lcms2</a>.
</p>

<hr/>
<h3><a name="whydbnotxml">Why are the mappings stored in a database, not readable XML files?</a></h3>
<p>
If you have a registry that more than one program is changing, you
<b>need</b> locking.
Locking with plain files is neither fun nor reliable.
From a raw performance point of view, it's two order of magnitudes
faster to mmap a single 20k sqlite .db file than it is to read 200
small XML files from the file system.
</p>
<p>
The session needs to <b>query</b> things like <i>give me all the
profiles for device $foo</i> and <i>find all the devices that use
profile $bar</i> which is why we should be using a database, rather than
searching discrete files on the file system every time the session asks
for data.
</p>
<p>
If we're <i>exchanging</i> files between users, then single files do
start to make sense.
I don't personally see a use case where I want to exchange low level
device->profile settings data with somebody else.
A chain of settings from document to printer would be a very useful
thing, but this is what you generate for a process and ship, rather
than copy from the file system unchanged.
</p>
<p>
Having power users <i>tweaking</i> the mapping is something that does
not make good design.
These people can use the <code>colormgr</code> command line client to
add and remove mappings, and to append qualifiers to certain profiles in
a safe abstracted way.
</p>

<hr/>
<h3><a name="nvidia-driver">Does calibration work with the NVIDIA binary driver?</a></h3>
<p>
The binary driver from NVIDIA only supports XRandR 1.2, which means that
it does not support per-monitor gamma tables.
This means we can only send gamma correction tables to the screen, which
means multiple monitor would not be supported.
</p>
<p>
As the driver has no source code, we can't fix this and have to wait for
NVIDIA to release a fixed version of their driver.
Nowadays the open source nouveau driver provides a much better
experience for NVIDIA hardware, and gnome-color-manager of course works
flawlessly with all of the open source drivers.
</p>

<hr/>
<h3><a name="cmm-cmf-cms">What is the difference between a CMM, CMF and a CMS?</a></h3>
<p>
A CMM (Color Management Module) is the software component that takes the
pixels in an image and converts them from one colorspace to another.
There are several CMM engines in existence, both free and proprietary.
Free CMM engines include ArgyllCMS and lcms2, of which the latter is
used heavily by colord and both are used by gnome-color-manager.
</p>
<p>
A CMF (Color Management Framework) is a software component that allows
applications to register devices and profiles, and also allows
applications to query what profiles to use for a device.
A CMF is a higher logical layer component to a CMM engine -- in this
way, colord aims to be a CMF, and is not a CMM.
</p>
<p>
It is the authors opinion that the abbreviation CMS is a heavily
overloaded term (in that ArgyllCMS and L[ittle]CMS include them in thier
name), but do not actually provide a system framework for other
applications to use.
In casual usage, both LCMS and colord exhibit some parts of a complete
CMS, and in this way CMS is often used as a general term for both a
CMM and a CMF.
</p>

<!--
<hr/>
<h3><a name="xxxxxxxxxxxxxxxxxxxxxxxxxxx">ccccccccccccccccccccccccccccccc</a></h3>
<p>
ccccccccccccccccccccccccccccccccccccccccccccccccccccc.
</p>
-->

<hr/>
<h3><a name="sensors">What is a native sensor?</a></h3>
<p>
A native sensor is a calibration device such as a colorimeter or
photospectrometer that colord knows how to interface with.
</p>
<p>
Many sensor makes and models are recognised, and are available to be used
by programs such as <a href="http://www.argyllcms.com/">ArgyllCMS</a>.
Only the <a href="http://www.pantone.co.uk/pages/products/product.aspx?pid=562">Pantone Huey</a>
device is available for use in colord by default, as colord contains a
native driver for this device.
</p>
<p>
A native driver allows colord to lock the device, read a sample from the
sensors (or from the ambient light sensor) and unlock the device.
A native device allows client programs to get samples from the device
trivially using either raw D-Bus or libcolord without relying on external
programs.
</p>
<p>
The author is also working on a Pantone ColorMunki native driver and
other hardware can supported if it is sent to the developer, or if
specifications can be obtained.
Email me if you can help.
</p>

<hr/>
<h3><a name="qualifiers">What is a qualifier used for?</a></h3>
<p>
A qualifier is a single string with three sub-strings joined with dots.
For example, <code>RGB.Glossy.300dpi</code> would be the qualifier on
a profile for a RGB device, printing on glossy paper and at 300 dots-per-inch.
</p>
<p>
Qualifiers are assigned to a profile either by CUPS itself or by the user
and this allows CUPS to choose the correct profile for a given print job.
The sub-strings are tried in preference order, so that for a print job
of type <code>RGB.Glossy.300dpi</code> the following fallbacks would be
used:
</p>
<ol>
<li><code>RGB.Glossy.300dpi</code></li>
<li><code>RGB.Glossy.*</code></li>
<li><code>RGB.*.300dpi</code></li>
<li><code>RGB.*.*</code></li>
<li><code>*</code></li>
</ol>
<p>
The fallback scheme allows one profile to potentially match lots of
different print conditions, as very few users will have more than
a couple of different printer profiles.
</p>
<p>
The tri-dotted notation was chosen in preference to JSON or XML as it
is <a href="http://www.cups.org/documentation.php/doc-1.4/spec-ppd.html#cupsICCProfile">
already being used by CUPS</a> in the <code>cupsICCProfile</code> PPD
Extensions format.
</p>

<hr/>
<h3><a name="application">How would an application like Simple Scan use colord?</a></h3>
<p>
It's actually really easy.
Simple Scan already knows the <code>SANE_Device</code> object of the
scanner that it wants to use.
From the <code>SANE_Device</code> object we can easily get the
<i>device_id</i> for the color managed device in colord.
To do this, refer to the <a href="http://gitorious.org/colord/master/blobs/master/doc/device-and-profile-naming-spec.txt">
device and profile specification</a> for scanner devices.
This specifies the <i>device_id</i> for a sane device is made up from
<code>"sane_" + sane_device->model</code>.
</p>
<p>
We can now query colord using <a href="http://colord.hughsie.com/api/">
libcolord</a> for the device that matches this ID:
</p>
<pre>
    CdClient *client = NULL;
    CdDevice *device = NULL;
    CdProfile *profile = NULL;
    GError *error = NULL;

    /* create a connection to colord */
    client = cd_client_new ();

    /* find the device for a specific ID */
    device = cd_client_find_device_sync (client, device_id, NULL, &amp;error);
    if (device == NULL) {
        g_warning ("failed to find a device in colord: %s,
                   error->message);
        g_error_free (error);
        goto out;
    }

    /* get the default profile for this device */
    profile = cd_device_get_default_profile (device);
    if (profile == NULL)
        goto out;

    /* TODO: use lcms to convert the scanned image */
    g_message ("need to use: %s", cd_profile_get_filename (profile));
out:
    if (profile != NULL)
        g_object_unref (profile);
    if (device != NULL)
        g_object_unref (device);
    g_object_unref (client);
</pre>
<p>
If you're not happy gaining an additional dependency of libcolord, then
it's also pretty easy to use raw D-Bus calls to do the same thing.
See the <a href="http://gitorious.org/colord/master/trees/master/examples">
examples</a> folder for some code samples.
</p>

<hr/>
<h3><a name="daemon">How do system daemons add devices and profiles?</a></h3>
<p>
Like this:
</p>
<pre>
    for device in self.devices:
        o = CreateDevice(device.name)
        for profile in device.profiles:
            p = AddProfile(profile.id)
            if profile.icc_filename:
                p.SetFilename(profile.icc_filename)
            p.SetQualifier(profile.qualifier)
            o.AddProfile(p)
</pre>

<hr/>
<h3><a name="cups">How would a system daemon like CUPS use colord?</a></h3>
<p>
Like this:
</p>
<pre>
    d = FindDeviceById(device.name)
    if d:
        p = d.GetProfileForQualifier(qualifier)
        if p:
            p.Use()
</pre>

<hr/>
<h3><a name="translation">How do I translate gnome-color-manager?</a></h3>
<p>
See the <a href="http://l10n.gnome.org/teams">GNOME Translation Team</a>
web pages for how to contribute to GNOME localisation.
</p>

<hr/>
<h3><a name="corporate-sponsor">Is there an organization or corporation sponsoring development of colord?</a></h3>
<p>
colord is not sponsored by anyone, although
<a href="http://www.redhat.com">Red Hat</a> gives me the time to
work on random open source projects. Thanks!
</p>

<hr/>
<h3><a name="oyranos">Why did you start a new project instead of fixing Oyranos?</a></h3>
<p>
On the surface, <a href="http://www.oyranos.org/">Oyranos</a> and colord
look like similar projects.
Oyranos has been around for over 3 years, whilst colord has been designed
and developed for just over a year.
So why start something from scratch rather than just fix Oyranos?
</p>
<p>
Oyranos is a huge project with hundreds of thousands of lines of code.
It has a hard dependency of <a href="http://elektra.g4ii.com/Main_Page">elektra</a>,
which is <a href="https://www.ohloh.net/p/7750">dead upstream</a>.
Elektra could be replaced by an other configuration engine, although the
maintainer is unwilling to do so.
Elektra is not a supported library in any mainstream distribution and
is not used by any modern open source projects or frameworks.
</p>
<p>
Oyranos also uses FLTK widgets rather than integrating with the native
toolkit and includes a huge amount of code for a custom type and object
system and even includes its own memory allocation framework.
It wraps LCMS and expects all application code to use liboyranos rather
than doing the transform on the GPU or in a GLSL shader.
</p>
<p>
Oyranos also has the concept of profiles: <i>office</i>,
<i>photographer</i>, <i>prepress</i> and <i>designer</i>.
colord has no such distinction.
This is a deliberate choice as users vary rarely sit into well defined
groups and putting profiles in the UI abstracts the settings one stage
further from what the user is trying to achieve.
</p>
<p>
To do full screen color management, Oyranos also relies on the Compiz
display manager, rather than using GNOME Shell or KWin.
Oyranos also does not use DBus, as it aims to be portable to Linux, OSX
and Windows.
In my opinion, it is better to leverage the native color management
stack for each operating system, for instance, using Windows Color
System on win32, and ColorSync on OSX rather than try to install
alongside the existing frameworks.
</p>
<p>
So, in summary: Oyranos tries to to be a <i>thick</i> solution where it
tries to do everything, but relies on several of obsolete or undesirable
toolkits.
By comparison, colord is a <i>thin</i> framework composed of a simple
DBus daemon that aims to provide just the configuration and policy just
for Linux.
By using GLib and DBus, colord is a very small code base that is easy to
maintain, fix and audit.
No distribution currently includes Oyranos on the default install.
</p>
<p>
I do think the concept of a <i>monolithic</i> CMS is flawed.
Color management has to be integral to the stack, so Xorg, GTK, Cairo,
etc. all have to be patched so this stuff <b>"just works"</b>.
You can't really push an external monolithic library when you need to
interface with so many parts of the stack.
</p>

<hr/>
<h3><a name="why-root">Why does the daemon run as root?</a></h3>
<p>
Since version 0.1.12 (released August 2011) colord runs as the
<i>colord</i> user, not <i>root</i> &#151; if you're still running this or
an older version please file a bug with your distribution to get it to
upgrade the package to something more modern!
</p>
<p>
The original reason for running as the root user was to check the PolicyKit
authorisation request, but PolicyKit 0.104 (released October 2011)
added functionality to allow non-root daemons to do this as well.
</p>

<p>Back to the <a href="index.html">main page</a></p>

<p class="footer">
 Copyright <a href="mailto:richard@hughsie.com">Richard Hughes 2011</a><br/>
 <a href="http://validator.w3.org/check/referer">Optimized</a>
 for <a href="http://www.w3.org/">standards</a>.
</p>

</body>
</html>

